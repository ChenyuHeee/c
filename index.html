<!--Version:1.2.2-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>C 语言在线编译器 | HCY ZJU</title>
    <!-- 字体图标和 Monaco 加载器 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/loader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uncrustify-wasm@2.0.1/dist/uncrustify.js"></script>

    <!-- Highlight.js themes (prefetch links; actual enable/disable handled by script) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css" id="hljs-theme-dark" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css" id="hljs-theme-light" disabled>

    <style>
        :root{
            --sidebar-width: 380px;
            --bg: #0b0c0d;           /* 页面背景（near black） */
            --panel: #0f1113;        /* 卡片 / 主容器背景 */
            --muted: #9aa4ad;        /* 次要文字 */
            --accent: #48a0ff;       /* 高亮色（适度） */
            --glass: rgba(255,255,255,0.02);
            --radius: 10px;
            --shadow: 0 8px 30px rgba(0,0,0,0.6);
        }

        /* 明亮主题覆盖变量（切换时将 body 添加 .light-theme） */
        .light-theme{
            --bg: #f3f6fb;
            --panel: #ffffff;
            --muted: #4b5563;
            --accent: #2563eb;
            --glass: rgba(0,0,0,0.04);
            --shadow: 0 4px 16px rgba(0,0,0,0.08);
        }
        body.light-theme .frame{background:var(--panel)}
        body.light-theme header{background:linear-gradient(180deg,#ffffff,rgba(255,255,255,0.85))}
        body.light-theme .toolbar{background:#ffffff;border-top:1px solid rgba(0,0,0,0.08)}
        body.light-theme .sidebar{background:linear-gradient(180deg,#ffffff,rgba(255,255,255,0.85))}

        *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    body{background:var(--bg);color:var(--muted);transition:background-color .45s ease,color .45s ease}

        /* 应用容器：占满整个视口，类似本地 app 的全屏编辑器 */
        .app{height:100vh;width:100vw;display:flex;flex-direction:column;align-items:stretch;justify-content:stretch}
    .frame{max-width:1400px;margin:12px auto;flex:1;background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;display:flex;flex-direction:column;transition:background-color .45s ease,box-shadow .45s ease;min-height:0;width:100%}

    header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);transition:background-color .45s ease}
        header .title{display:flex;align-items:center;gap:10px;font-weight:600}
        header .title i{color:var(--accent);font-size:18px}
    header .meta{color:var(--muted);font-size:13px}
    header .meta a{color:var(--muted);text-decoration:none;display:inline-flex;align-items:center;gap:6px;cursor:pointer}
    header .meta a:hover{color:var(--accent);text-decoration:underline}

    /* 主区：编辑器 + 侧栏 */
    .main{flex:1;display:flex;min-height:0;position:relative}

        /* 编辑区 */
    .editor-wrap{flex:1;display:flex;flex-direction:column;border-right:1px solid rgba(0,0,0,0.06);transition:background-color .4s ease,border-color .4s ease;z-index:5;min-height:0}
    .editor-head{display:flex;align-items:center;justify-content:space-between;padding:10px 14px}
    .editor-head h2{font-size:14px;color:#dbe9ff}
    #editor{flex:1;min-height:0;height:100%}

        /* 工具栏 */
        .toolbar{display:flex;gap:8px;padding:10px 14px;align-items:center}
    .btn{border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;display:inline-flex;align-items:center;gap:8px;background:transparent;color:var(--muted);transition:color .3s}
    .btn.primary{background:var(--accent);color:#071022}
    .btn.ghost{border:1px solid rgba(0,0,0,0.06)}
    /* 按钮禁用视觉状态 */
    .btn[disabled]{opacity:.45;cursor:not-allowed;filter:grayscale(25%)}

    /* 侧栏 */
    /* 侧栏：使用绝对定位以覆盖编辑区，避免被 Monaco canvas 遮挡 */
    /* 侧栏：覆盖式定位，但保留顶部与底部间隔，避免遮挡 header 与 底部工具栏；JS 会在运行时计算精确的 top/bottom */
    .sidebar{width:var(--sidebar-width);display:flex;flex-direction:column;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);transition:width .28s ease,opacity .28s ease,padding .28s ease;position:absolute;right:0;top:56px;bottom:72px;z-index:1000}
    /* 折叠侧栏：设置宽度为0并隐藏内边距，编辑器会自动占满剩余空间 */
    .sidebar.collapsed{width:0;padding:0;opacity:0;pointer-events:none}
        .sb-head{display:flex;align-items:center;justify-content:space-between;padding:12px 14px}
        .sb-section{padding:12px 14px;flex:1;overflow:auto}
        textarea,input[type=text]{width:100%;padding:10px;border:1px solid rgba(255,255,255,0.03);border-radius:8px;background:transparent;color:#e6eef6;font-family:monospace}
        .output{background:var(--glass);color:#dfefff;padding:12px;border-radius:8px;white-space:pre-wrap;height:100%;overflow:auto;font-family:monospace}

    /* 悬浮的侧边栏切换按钮（当侧栏折叠时可恢复） */
    #sidebarToggle{position:fixed;right:18px;bottom:24px;width:44px;height:44px;border-radius:10px;background:var(--panel);border:1px solid rgba(0,0,0,0.06);display:flex;align-items:center;justify-content:center;color:var(--accent);box-shadow:var(--shadow);cursor:pointer;transition:opacity .2s;z-index:2000}

    /* 注意：编辑器保持始终填满宽度，侧栏是覆盖式的但上下有留白以避免遮挡头部与底部控件 */

        /* 小屏适配 */
        @media (max-width:900px){
            .main{flex-direction:column}
            .sidebar{width:100%;height:34%}
        /* 确保编辑器画布不挡住侧栏：编辑器区域的层级要低于侧栏 */
        #editor{position:relative;z-index:10}
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="frame">
        <header>
            <div class="title"><i class="fas fa-code"></i><div>Online C Compiler</div></div>
        </header>

        <div class="main">
            <div class="editor-wrap">
                <div class="editor-head">
                    <h2><i class="fas fa-file-code"></i> <span id="fileTitle">main.c</span></h2>
                    <!-- 移除冗余的文字状态提示，仅保留文件名星号表示未保存 -->
                    <div style="flex:1"></div>
                    <button class="btn ghost" id="saveAsBtn"><i class="fas fa-download"></i> 另存为</button>
                    <button class="btn ghost" id="themeBtn"><i class="fas fa-sun"></i> 主题</button>
                </div>
                <div id="editor"></div>
            </div>

            <aside class="sidebar" id="sidebar">
                <div class="sb-head"><div><i class="fas fa-terminal"></i> 运行结果</div><button id="closeSb" class="btn ghost">折叠</button></div>
                <div class="sb-section">
                    <label>输入 (stdin)</label>
                    <textarea id="stdin" rows="3" placeholder="请先输入再点击运行..."></textarea>
                    <div style="height:12px"></div>
                    <label>输出 (stdout)</label>
                    <div class="output" id="stdout">程序输出将显示在这里...</div>
                </div>
            </aside>
        </div>
        <!-- 底部工具栏：运行 / 打开 / 自动缩进 / 复制 / 撤销 / 重做 / 全屏 / 版权与版本号 -->
        <div class="toolbar">
            <button class="btn primary" id="runBtn"><i class="fas fa-play"></i> 运行</button>
            <button class="btn ghost" id="openFileBtn"><i class="fas fa-folder-open"></i> 打开</button>
            <button class="btn ghost" id="formatBtn"><i id="formatLoadingIcon" class="fas fa-indent"></i> <span id="formatBtnText">自动缩进</span></button>
            <button class="btn ghost" id="copyBtn" title="复制"><i class="fas fa-copy"></i> 复制</button>
            <button class="btn ghost" id="undoBtn" title="撤销" disabled><i class="fas fa-undo"></i></button>
            <button class="btn ghost" id="redoBtn" title="重做" disabled><i class="fas fa-redo"></i></button>
            <button class="btn ghost" id="fsBtn"><i class="fas fa-expand"></i> 全屏</button>
            <a id="versionLink" href="./CHANGELOG.md" target="_blank" style="margin-left:auto;color:var(--muted);font-size:12px;text-decoration:none">By C. He from ZJU | v1.2.2</a>
        </div>
        </div>
    </div>

    <!-- 折叠后恢复侧栏的悬浮按钮 -->
    <div id="sidebarToggle" title="打开侧栏"><i class="fas fa-chevron-left"></i></div>
    <!-- 隐藏的本地文件选择器 -->
    <input type="file" id="fileInput" accept=".c,.cpp,.h,.hpp,.txt" style="display:none" />

    <!-- Changelog modal (hidden by default) -->
    <div id="changelogModal" aria-hidden="true" style="display:none">
        <div class="changelog-sheet" role="dialog" aria-modal="true" aria-labelledby="changelogTitle">
            <button class="changelog-close" aria-label="关闭更新日志">✕</button>
            <div id="changelogContent"></div>
        </div>
    </div>

    <script>
        /**********************************************************************
         * 简洁版脚本：功能
         * - 初始化 Monaco 编辑器
         * - 本地保存/加载代码（localStorage）
         * - 简单运行（模拟 scanf/printf）
         * - 主题切换与 UI 状态更新
         * 所有注释为中文，便于维护。
         **********************************************************************/

        // 默认代码（保持与 UI 功能一致的示例）
        const DEFAULT_CODE = `#include <stdio.h>

int main() {
    printf("By ZJU C. He");
    return 0;
}`;

        // 编辑器脏标记（未保存状态）
        let isDirty = false;

        // DOM 引用
    const runBtn = document.getElementById('runBtn');
    const copyBtn = document.getElementById('copyBtn');
        const themeBtn = document.getElementById('themeBtn');
        const stdinEl = document.getElementById('stdin');
        const stdoutEl = document.getElementById('stdout');
        const saveStatus = document.getElementById('saveStatus');
        const closeSb = document.getElementById('closeSb');

        // Monaco 编辑器需要异步加载
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' } });
        require(['vs/editor/editor.main'], function () {
            // 尝试从 localStorage 加载之前保存的代码
            const saved = localStorage.getItem('deepseek_saved_c');
            window.editor = monaco.editor.create(document.getElementById('editor'), {
                value: saved || DEFAULT_CODE,
                language: 'c',
                theme: (localStorage.getItem('editorTheme') === 'light') ? 'vs-light' : 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                fontSize: 13,
                scrollBeyondLastLine: false
            });

            // 撤销/重做自动禁用：基于内容变更事件维护简易历史指针
            let __histIdx = 0;
            let __histMax = 0;
            function updateUndoRedoButtons(){
                try{
                    const undoBtn = document.getElementById('undoBtn');
                    const redoBtn = document.getElementById('redoBtn');
                    if (undoBtn) undoBtn.disabled = (__histIdx <= 0);
                    if (redoBtn) redoBtn.disabled = (__histIdx >= __histMax);
                }catch(e){}
            }
            updateUndoRedoButtons();

            try {
                window.editor.onDidChangeModelContent((e) => {
                    try{
                        if (e && e.isUndoing) {
                            __histIdx = Math.max(0, __histIdx - 1);
                        } else if (e && e.isRedoing) {
                            __histIdx = Math.min(__histMax, __histIdx + 1);
                        } else {
                            // 新编辑会截断 redo
                            if (__histIdx < __histMax) {
                                __histMax = __histIdx;
                            }
                            __histIdx += 1;
                            __histMax = __histIdx;
                        }
                    }catch(err){}
                    updateUndoRedoButtons();
                });
            } catch(e) {}

            // 应用 body 主题类（持久化）
            try { if (localStorage.getItem('editorTheme') === 'light') document.body.classList.add('light-theme'); } catch (e) {}

            // 编辑器内容改变时标记为未保存（添加 '*'）
            try {
                window.editor.onDidChangeModelContent(() => {
                    if (!isDirty) setDirty(true);
                });
            } catch (e) {}

            // 移除 Ctrl/Cmd+S 保存快捷键（仅保留另存为功能）
        });

    // ----------------- 功能函数 -----------------

        // runCode: 优先尝试 Wandbox（真实编译器），若失败尝试加载本地 WASM 运行器（若你已部署）
        // 最后回退到原有的模拟（simulateRun）。Wandbox API: https://wandbox.org
        async function tryWandboxCompile(code, stdin) {
            const wandboxUrl = 'https://wandbox.org/api/compile.json';
            const payload = {
                code,
                compiler: 'gcc-head', // 可改为 clang-head 或其他
                stdin: stdin || undefined,
                save: false
            };

            const fetchWithTimeout = (url, opts, timeout = 8000) => {
                return Promise.race([
                    fetch(url, opts),
                    new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), timeout))
                ]);
            };

            const resp = await fetchWithTimeout(wandboxUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }, 10000);

            if (!resp.ok) throw new Error('Wandbox 返回 ' + resp.status);
            const json = await resp.json();

            // Wandbox 返回字段不总是固定，常见有: program_output / program_error / compiler_output
            const out = (json.program_output || json.program_stdout || json.program || json.result || '') || '';
            const err = (json.program_error || json.program_stderr || json.compiler_error || json.compiler_output || '') || '';
            const status = json.status ?? 0;
            return { stdout: out, stderr: err, exitCode: status };
        }

        // 动态加载前端 WASM 运行器（如果你在 repo 下放置了 /wasm/tcc_runner.js）
        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = url;
                s.onload = () => resolve();
                s.onerror = (e) => reject(new Error('加载失败: ' + url));
                document.head.appendChild(s);
            });
        }

        // 如果用户在仓库中放置了一个基于 tcc/clang 的 wasm 运行器并暴露 window.wasmRun(code, stdin)
        async function tryWasmRun(code, stdin) {
            // 常用路径：/wasm/tcc_runner.js（你需要把相应的脚本和 wasm 放到该路径）
            if (typeof window.wasmRun === 'function') {
                return await window.wasmRun(code, stdin);
            }

            // 尝试动态加载预期的脚本（如果你已上传）
            try {
                await loadScript('/wasm/tcc_runner.js');
                if (typeof window.wasmRun === 'function') {
                    return await window.wasmRun(code, stdin);
                } else {
                    throw new Error('wasmRun 未在脚本中暴露');
                }
            } catch (e) {
                throw e;
            }
        }

        async function runCode() {
            if (!window.editor) return;
            const code = window.editor.getValue();
            const stdin = (stdinEl.value || '').trim();
            stdoutEl.textContent = '运行中（Wandbox 优先）...';
            try {
                const res = await tryWandboxCompile(code, stdin);
                let out = '';
                if (res.stdout) out += res.stdout;
                if (res.stderr) out += '\n[stderr]\n' + res.stderr;
                out += `\n[exit code] ${res.exitCode ?? 0}`;
                stdoutEl.textContent = out.trim();
                return;
            } catch (e) {
                console.warn('Wandbox 调用失败：', e);
                stdoutEl.textContent = 'Wandbox 不可用，回退到本地模拟...';
            }
            simulateRun(code, stdin);
        }

        // 本地回退：简单模拟 scanf/printf 行为（仅作演示）
        function simulateRun(code, input) {
            stdoutEl.textContent = '本地模拟运行...';
            setTimeout(() => {
                if (/scanf\s*\(/.test(code) && (!input || input.trim() === '')) {
                    stdoutEl.textContent = '错误：程序需要输入但未提供 stdin。';
                    return;
                }

                if (!input || input.trim() === '') {
                    stdoutEl.textContent = '提示：请在左侧输入两个整数，例如：10 20';
                    return;
                }

                const parts = input.split(/\s+/).map(s => parseInt(s, 10));
                if (parts.length >= 2 && parts.every(n => Number.isFinite(n))) {
                    const [a, b] = parts;
                    stdoutEl.textContent = `两数之和为：${a + b}`;
                } else {
                    stdoutEl.textContent = '错误：输入格式不正确，请输入两个整数（例如：10 20）';
                }
            }, 300);
        }

        // 切换主题（轻/暗），默认暗黑。我们通过 body 的 .light-theme 类切换 CSS 变量
        // 主题持久化到 localStorage: 'editorTheme' = 'dark' | 'light'
        let isDark = true;
        // 读取持久化主题（若存在）
        try {
            const stored = localStorage.getItem('editorTheme');
            if (stored) isDark = stored === 'dark';
        } catch (e) {}

        function applyThemeImmediately() {
            document.body.classList.toggle('light-theme', !isDark);
            try { if (window.monaco) monaco.editor.setTheme(isDark ? 'vs-dark' : 'vs-light'); } catch (e) {}
            themeBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i> 明亮' : '<i class="fas fa-moon"></i> 暗色';
        }

        function toggleTheme() {
            isDark = !isDark;
            // 持久化
            try { localStorage.setItem('editorTheme', isDark ? 'dark' : 'light'); } catch (e) {}
            // 添加/移除全局类以切换 CSS 变量（平滑过渡）
            document.body.classList.toggle('light-theme', !isDark);
            // 更新按钮文案并在短延迟后切换 Monaco 主题，避免强烈反差
            themeBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i> 明亮' : '<i class="fas fa-moon"></i> 暗色';
            try {
                setTimeout(() => {
                    monaco.editor.setTheme(isDark ? 'vs-dark' : 'vs-light');
                }, 180);
            } catch (e) {}
        }

    // ----------------- 事件绑定 -----------------
    // 常规绑定（若此时元素存在）
    try { runBtn && runBtn.addEventListener('click', runCode); } catch (e) {}
        try {
            const copyBtn = document.getElementById('copyBtn');
            copyBtn && copyBtn.addEventListener('click', () => {
                try {
                    const code = window.editor ? window.editor.getValue() : '';
                    navigator.clipboard.writeText(code).then(() => {
                        copyBtn.innerHTML = '<i class="fas fa-check"></i> 已复制';
                        setTimeout(()=>{copyBtn.innerHTML = '<i class="fas fa-copy"></i> 复制';},1200);
                    }).catch(err => { alert('复制失败: ' + err.message); });
                } catch(e){ alert('复制失败'); }
            });
        } catch (e) {}
    // 保存与重置功能已移除
    try { themeBtn && themeBtn.addEventListener('click', toggleTheme); } catch (e) {}
    // 撤销/重做按钮绑定（脚本区正确绑定）
    try {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        if (undoBtn) undoBtn.addEventListener('click', () => { if (window.editor) window.editor.trigger('toolbar','undo'); });
        if (redoBtn) redoBtn.addEventListener('click', () => { if (window.editor) window.editor.trigger('toolbar','redo'); });
    } catch(e) {}
    // 纯 JS 高级 C 代码自动缩进美化
    (function(){
        const formatBtn = document.getElementById('formatBtn');
        const formatIcon = document.getElementById('formatLoadingIcon');
        const formatText = document.getElementById('formatBtnText');
        if (!formatBtn) return;
        formatBtn.disabled = false;
        function smartCIndent(code, tabSize) {
            tabSize = tabSize || 4;
            const tab = ' '.repeat(tabSize);
            const lines = code.split(/\r?\n/);
            let indent = 0;
            let inBlockComment = false, inString = false, stringChar = '';
            let result = [];
            // 控制流栈：记录无大括号的单行体（single）与 do...while（do）
            // 栈元素：{ type: 'single'|'do', applied: boolean }
            let controlStack = [];
            let inSwitch = false, inCase = false, caseIndent = 0;
            const controlRegex = /^(if|for|while|else if|else|do|switch)\b.*\)?\s*$/;
            const elseRegex = /^else(\s+if)?\b/;
            const caseRegex = /^(case |default:)/;
            for (let idx = 0; idx < lines.length; idx++) {
                let rawLine = lines[idx];
                let line = rawLine.trimEnd();
                let trimmed = line.trim();
                // 预处理指令 # 开头不缩进
                if (/^#/.test(trimmed)) {
                    result.push(trimmed);
                    continue;
                }
                // 处理多行注释
                let i = 0, n = line.length, openBraces = 0, closeBraces = 0, caseOrDefault = false;
                while (i < n) {
                    let ch = line[i];
                    // 跳过字符串
                    if (!inBlockComment && !inString && (ch === '"' || ch === "'")) {
                        inString = true; stringChar = ch; i++;
                        continue;
                    }
                    if (inString) {
                        if (ch === '\\' && i+1 < n) { i+=2; continue; }
                        if (ch === stringChar) { inString = false; stringChar = ''; }
                        i++;
                        continue;
                    }
                    // 跳过注释
                    if (!inBlockComment && ch === '/' && i+1 < n && line[i+1] === '*') {
                        inBlockComment = true; i+=2; continue;
                    }
                    if (inBlockComment) {
                        if (ch === '*' && i+1 < n && line[i+1] === '/') { inBlockComment = false; i+=2; continue; }
                        i++;
                        continue;
                    }
                    // 单行注释
                    if (!inString && ch === '/' && i+1 < n && line[i+1] === '/') break;
                    // 统计大括号
                    if (!inString && !inBlockComment) {
                        if (ch === '{') openBraces++;
                        if (ch === '}') closeBraces++;
                    }
                    i++;
                }
                // case/default 语句减少一级缩进
                if (caseRegex.test(trimmed)) caseOrDefault = true;
                // switch-case 缩进处理
                if (/^switch\b/.test(trimmed)) {
                    inSwitch = true;
                    caseIndent = indent;
                }
                if (inSwitch && caseRegex.test(trimmed)) {
                    inCase = true;
                }
                if (inCase && !caseRegex.test(trimmed) && trimmed && !trimmed.startsWith('}') && !trimmed.startsWith('{')) {
                    // case 内多行语句缩进
                    indent++;
                }
                // 控制流缩进栈处理
                // 检查是否为控制语句且不以 { 结尾
                let isControl = controlRegex.test(trimmed) && !trimmed.endsWith('{');
                // do...while 特殊处理
                let isDo = /^do\b/.test(trimmed);
                let isWhile = /^while\b/.test(trimmed);
                let isElse = elseRegex.test(trimmed);
                // } 在行首则先减少缩进
                let effectiveIndent = indent;
                if (trimmed.startsWith('}')) effectiveIndent = Math.max(0, indent-1);
                if (caseOrDefault) effectiveIndent = Math.max(0, effectiveIndent-1);
                // else if/else 缩进对齐
                if (isElse && result.length > 0) {
                    // else/else if 与前一行对齐
                    let prev = result[result.length-1];
                    let prevIndent = prev.match(/^(\s*)/)[1].length/tabSize;
                    effectiveIndent = prevIndent;
                }
                // 计算单行体的额外缩进：当上一行是控制语句且无大括号时，从本行开始额外 +1
                const controlStart = /^(if|for|while|else|do|switch)\b/;
                const isSignificantStatement = (s) => {
                    if (!s) return false;
                    if (s.startsWith('#')) return false;
                    if (s.startsWith('{') || s.startsWith('}')) return false;
                    if (s.startsWith('//')) return false;
                    if (caseRegex.test(s)) return false; // case/default 标签不算语句
                    if (controlStart.test(s)) return false; // 控制行本身不作为被控制语句
                    return true;
                };
                // 标记本行是否开始成为某个 single/do 的受控语句
                for (let k = 0; k < controlStack.length; k++) {
                    const item = controlStack[k];
                    if (!item.applied && isSignificantStatement(trimmed)) item.applied = true;
                }
                // 应用额外缩进（嵌套 single/do 每个 +1）
                const extraSingles = controlStack.reduce((acc, it) => acc + (it.applied ? 1 : 0), 0);
                effectiveIndent += extraSingles;
                // 入栈：本行若是控制语句（非 do）且不以 { 结束，则登记为 single；do 单独登记为 do
                if (isDo) {
                    controlStack.push({ type:'do', applied:false });
                } else if (isControl) {
                    controlStack.push({ type:'single', applied:false });
                }
                // 输出缩进
                result.push(tab.repeat(effectiveIndent) + trimmed);
                // 行内 } 多于 {，则减少缩进
                indent += openBraces - closeBraces;
                if (trimmed.startsWith('}')) indent = Math.max(0, indent);
                // 控制流栈弹出逻辑
                if (controlStack.length > 0) {
                    // 若遇到块开始 '{'，说明不是单行体：清理所有未应用的 single/do
                    if (trimmed.startsWith('{')) {
                        controlStack = controlStack.filter(it => it.applied);
                    }
                    // do...while：在 while(...); 行弹出最近的 do
                    if (isWhile && trimmed.endsWith(';')) {
                        for (let p = controlStack.length - 1; p >= 0; p--) {
                            if (controlStack[p].type === 'do') { controlStack.splice(p,1); break; }
                        }
                    }
                    // 单行体：到达语句结束（以 ; 结尾）后弹出所有已应用的 single
                    if (trimmed.endsWith(';')) {
                        controlStack = controlStack.filter(it => !(it.type==='single' && it.applied));
                    }
                }
                // switch-case 缩进恢复
                if (inCase && (trimmed.endsWith('break;') || trimmed.endsWith('return;') || trimmed.endsWith('continue;') || trimmed.endsWith('goto;') || trimmed.endsWith('}') || trimmed === '')) {
                    indent = caseIndent;
                    inCase = false;
                }
                // 关闭 switch
                if (inSwitch && trimmed.startsWith('}')) {
                    inSwitch = false;
                    inCase = false;
                }
            }
            return result.join('\n');
        }
        formatBtn.addEventListener('click', function() {
            if (!window.editor) return;
            try {
                formatBtn.disabled = true;
                if (formatIcon) formatIcon.className = 'fas fa-spinner fa-spin';
                formatText.textContent = '格式化中...';
                const code = window.editor.getValue();
                const formatted = smartCIndent(code, 4);
                if (formatted) window.editor.setValue(formatted);
            } catch (err) {
                alert('格式化失败：' + (err && err.message));
            } finally {
                formatBtn.disabled = false;
                if (formatIcon) formatIcon.className = 'fas fa-indent';
                formatText.textContent = '自动缩进';
            }
        });
    })();

        // 侧栏折叠/展开逻辑：使用 class 'collapsed'，便于动画与恢复
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const editorWrap = document.querySelector('.editor-wrap');
        closeSb.addEventListener('click', () => {
            sidebar.classList.add('collapsed');
            sidebarToggle.style.display = 'flex';
            // 折叠侧栏时不改变编辑器宽度（编辑器始终填满宽度），仅触发布局
            try { editorWrap && editorWrap.classList.add('full'); } catch (e) {}
            setTimeout(() => { try { window.editor && window.editor.layout(); } catch (e) {} }, 320);
        });
        sidebarToggle.addEventListener('click', () => {
            // 展开侧栏：先移除 collapsed，使其恢复到正常宽度
            sidebar.classList.remove('collapsed');
            // 强制一次重排以确保浏览器应用宽度变化（防止 Monaco 的 canvas 覆盖侧栏）
            // 读取 offsetWidth 会触发回流
            try { void sidebar.offsetWidth; } catch (e) {}
            // 隐藏恢复按钮
            sidebarToggle.style.display = 'none';
            // 恢复侧栏显示后只需触发布局，编辑器仍保持填满宽度
            try { editorWrap && editorWrap.classList.remove('full'); } catch (e) {}
            // 立即触发一次布局以快速响应，稍后 transitionend 会触发最终布局
            try { window.editor && window.editor.layout(); } catch (e) {}
            setTimeout(() => { try { window.editor && window.editor.layout(); } catch (e) {} }, 180);
        });

        // 当侧栏过渡结束时，确保编辑器做最终布局（避免动画中 canvas 与侧栏出现错位）
        try {
            sidebar.addEventListener('transitionend', (ev) => {
                const prop = (ev && ev.propertyName) || '';
                if (prop.includes('width') || prop.includes('margin') || prop.includes('right') || prop.includes('opacity')) {
                    try { window.editor && window.editor.layout(); } catch (e) {}
                }
            });
        } catch (e) {}

        // 监听侧栏的折叠/展开和窗口尺寸以动态调整侧栏的上下边界，保证不遮挡头部与底部控件
        try {
            function adjustSidebarVertical() {
                try {
                    const headerEl = document.querySelector('header');
                    const toolbarEl = document.querySelector('.toolbar');
                    if (!headerEl || !toolbarEl) return;
                    const headerRect = headerEl.getBoundingClientRect();
                    const toolbarRect = toolbarEl.getBoundingClientRect();
                    // 计算顶部距离：将侧栏顶边放在 header 底部 + 8px 间隔
                    const topPx = Math.max(8, Math.round(headerRect.bottom + 8));
                    // 计算底部距离：将侧栏底边放在 toolbar 顶部 - 8px 间隔
                    const bottomPx = Math.max(8, Math.round(window.innerHeight - toolbarRect.top + 8));
                    sidebar.style.top = topPx + 'px';
                    sidebar.style.bottom = bottomPx + 'px';
                } catch (e) {}
            }
            // 初始调整
            adjustSidebarVertical();
            // 在窗口调整时重新计算
            window.addEventListener('resize', adjustSidebarVertical);
            // 在侧栏折叠/展开后也调整（transitionend 也会触发 editor.layout）
            sidebar.addEventListener('transitionend', adjustSidebarVertical);
            // 当用户点击折叠/展开按钮后立即调整并触发布局
            closeSb.addEventListener('click', () => { try { adjustSidebarVertical(); window.editor && window.editor.layout(); } catch (e) {} });
            sidebarToggle.addEventListener('click', () => { try { adjustSidebarVertical(); window.editor && window.editor.layout(); } catch (e) {} });
        } catch (e) {}

        // 更新脏标记 UI（仅在文件名后显示 '*'）
        function setDirty(flag) {
            try {
                isDirty = !!flag;
                const title = currentFilename || 'main.c';
                fileTitle.textContent = title + (isDirty ? ' *' : '');
            } catch (e) {}
        }

    // 打开本地文件：触发隐藏的 file input，读取文本并替换编辑器内容
    const openFileBtn = document.getElementById('openFileBtn');
    const fileInput = document.getElementById('fileInput');
    const fileTitle = document.getElementById('fileTitle');
    const saveAsBtn = document.getElementById('saveAsBtn');
    let currentFilename = 'main.c';
        openFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (ev) => {
            const f = ev.target.files && ev.target.files[0];
            if (!f) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                // 如果当前编辑器内容与已保存的不一致，提醒用户
                try {
                    const current = window.editor ? window.editor.getValue() : '';
                    const saved = localStorage.getItem('deepseek_saved_c') || '';
                    if (current !== saved) {
                        const ok = confirm('当前编辑器中有未保存的更改，打开本地文件将覆盖它，继续吗？');
                        if (!ok) return;
                    }
                } catch (e) {}
                try {
                    // 将文件内容写入编辑器
                    window.editor && window.editor.setValue(text);
                    window.editor && window.editor.focus();
                    // 更新当前文件名显示
                    try { currentFilename = f.name || currentFilename; fileTitle.textContent = currentFilename; setDirty(false); } catch (e) {}
                    // 根据扩展设定语言模式（若 Monaco 已就绪）
                    try {
                        const name = f.name || '';
                        const ext = name.split('.').pop().toLowerCase();
                        let lang = 'plaintext';
                        if (ext === 'c' || ext === 'h') lang = 'c';
                        else if (ext === 'cpp' || ext === 'cxx' || ext === 'hpp' || ext === 'hxx') lang = 'cpp';
                        else lang = 'plaintext';
                        if (window.monaco && window.editor && window.editor.getModel) {
                            monaco.editor.setModelLanguage(window.editor.getModel(), lang);
                        }
                    } catch (e) {}
                } catch (e) {}
                // 清空选择以便再次打开同一文件
                fileInput.value = '';
            };
            reader.readAsText(f);
        });

        // 另存为：下载当前编辑器内容为文件
        function saveAsFile() {
            try {
                const content = window.editor ? window.editor.getValue() : '';
                const name = currentFilename || 'main.c';
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 5000);
                // 另存为并不改变脏状态
            } catch (e) {
                console.error('另存为失败', e);
                alert('另存为失败：' + (e && e.message));
            }
        }
        saveAsBtn.addEventListener('click', saveAsFile);

        // 全屏按钮（修复：提供回退以防 .frame 未定义）
        const fsBtn = document.getElementById('fsBtn');
        fsBtn.addEventListener('click', () => {
            // 首选 .frame，其次回退到 .app，再回退到 documentElement
            const el = document.querySelector('.frame') || document.querySelector('.app') || document.documentElement;
            if (!document.fullscreenElement) {
                el.requestFullscreen?.();
            } else {
                document.exitFullscreen?.();
            }
        });

        // 页面卸载时自动保存（可选）
        window.addEventListener('beforeunload', () => {
            if (window.editor) localStorage.setItem('deepseek_saved_c', window.editor.getValue());
        });


        // 页面加载时：设置编辑器为暗黑主题，并预热 clang-format wasm
        window.addEventListener('load', () => {
            try { if (window.monaco) monaco.editor.setTheme('vs-dark'); } catch (e) {}
            // 初始时隐藏侧栏恢复按钮（默认展开）
            document.getElementById('sidebarToggle').style.display = 'none';

            // 调整侧栏上下边界以避免遮挡头部和底部工具条
            try { /* 调整将在下面的调整函数中完成 */ } catch (e) {}

            // 确保 Monaco 布局正确——在某些浏览器/布局中首次渲染时需要手动触发 layout
            try { window.editor && window.editor.layout(); } catch (e) {}

            // 绑定全屏按钮（容错）：如果之前绑定失败，这里再绑定一次
            try {
                const fs = document.getElementById('fsBtn');
                if (fs && !fs.dataset._fsBound) {
                    fs.addEventListener('click', () => {
                        const el = document.querySelector('.frame') || document.querySelector('.app') || document.documentElement;
                        if (!document.fullscreenElement) {
                            el.requestFullscreen?.();
                        } else {
                            document.exitFullscreen?.();
                        }
                    });
                    fs.dataset._fsBound = '1';
                }
            } catch (e) {}

            // 已移除 WASM 选项

            // 主动预热 clang-format wasm，避免首次点击时未加载
            try {
                if (window['clangFormat']) {
                    window['clangFormat']('int main() {return 0;}', 'c').catch(()=>{});
                }
            } catch(e) {}
        });

        // 当窗口尺寸变化时，重新布局编辑器以适配容器大小
        window.addEventListener('resize', () => { try { window.editor && window.editor.layout(); } catch (e) {} });
    </script>

        <script src="/projects/compiler/changelog.js" defer></script>
</body>
</html>